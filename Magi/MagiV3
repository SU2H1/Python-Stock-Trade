import requests
from bs4 import BeautifulSoup
from transformers import BertForSequenceClassification, BertJapaneseTokenizer
import torch
import numpy as np
from datetime import datetime, timedelta
import json
from langdetect import detect
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
import yfinance as yf
import sys
from PyQt6.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton, QTextEdit, QMainWindow
from PyQt6.QtGui import QFont, QColor, QPalette
from PyQt6.QtCore import Qt, QTimer, QThread, pyqtSignal, QEventLoop
import os
import logging
import re

logging.basicConfig(filename='magi_stock_analysis.log', level=logging.INFO)

model_name = "cl-tohoku/bert-base-japanese-v2"
tokenizer = BertJapaneseTokenizer.from_pretrained(model_name)
model = BertForSequenceClassification.from_pretrained(model_name)


class StockUpdateThread(QThread):
    update_signal = pyqtSignal(dict)

    def __init__(self, stock_number):
        super().__init__()
        self.stock_number = stock_number
        self.running = True

    def run(self):
        while self.running:
            data = self.fetch_latest_data()
            self.update_signal.emit(data)
            self.sleep(1)  # Update every second

    def fetch_latest_data(self):
        try:
            current_price = self.get_current_stock_price()
            company_name = self.get_company_name()
            nikkei_news = self.scrape_nikkei_news()
            yahoo_news = self.scrape_yahoo_finance_news()
            nikkei_sentiment = self.analyze_sentiment(nikkei_news)
            yahoo_sentiment = self.analyze_sentiment(yahoo_news)
            stock_data = self.get_stock_data()
            psr, pbr = self.scrape_psr_pbr()
            technical_indicators = self.calculate_technical_indicators(stock_data)
            price_prediction = self.predict_price(stock_data)
            fundamental_data = self.get_fundamental_data(self.stock_number)
            market_sentiment = self.analyze_market_sentiment()
            
            return {
                'current_price': current_price,
                'company_name': company_name,
                'nikkei_sentiment': nikkei_sentiment,
                'yahoo_sentiment': yahoo_sentiment,
                'nikkei_news': nikkei_news,
                'yahoo_news': yahoo_news,
                'stock_data': stock_data,
                'psr': psr,
                'pbr': pbr,
                'technical_indicators': technical_indicators,
                'price_prediction': price_prediction,
                'fundamental_data': fundamental_data,
                'market_sentiment': market_sentiment
            }
        except Exception as e:
            logging.error(f"Error in fetch_latest_data: {str(e)}")
            return None

    def get_current_stock_price(self):
        try:
            url = f"https://finance.yahoo.co.jp/quote/{self.stock_number}.T"
            response = requests.get(url)
            soup = BeautifulSoup(response.content, 'html.parser')
            price_element = soup.select_one('span._3rXWJKZF')
            if price_element:
                price_text = price_element.text.strip().replace(',', '')
                return float(price_text)
            return None
        except Exception as e:
            logging.error(f"Error in get_current_stock_price: {str(e)}")
            return None

    def scrape_nikkei_news(self):
        try:
            url = f"https://www.nikkei.com/nkd/company/news/?scode={self.stock_number}&ba=1"
            response = requests.get(url)
            soup = BeautifulSoup(response.content, 'html.parser')
            news_items = soup.find_all('a', href=lambda href: href and "/nkd/company/article/" in href)
            news_data = []
            for item in news_items[:5]:  # Get latest 5 news items
                title = item.text.strip()
                url = "https://www.nikkei.com" + item['href']
                news_data.append({"title": title, "url": url})
            return news_data
        except Exception as e:
            logging.error(f"Error in scrape_nikkei_news: {str(e)}")
            return []

    def scrape_yahoo_finance_news(self):
        try:
            url = f"https://finance.yahoo.co.jp/quote/{self.stock_number}.T/news"
            response = requests.get(url)
            soup = BeautifulSoup(response.content, 'html.parser')
            news_items = soup.find_all('a', href=lambda href: href and "/news/" in href)
            news_data = []
            for item in news_items[:5]:  # Get latest 5 news items
                title = item.text.strip()
                article_url = item['href']
                if not article_url.startswith('http'):
                    article_url = "https://finance.yahoo.co.jp" + article_url
                news_data.append({"title": title, "url": article_url})
            return news_data
        except Exception as e:
            logging.error(f"Error in scrape_yahoo_finance_news: {str(e)}")
            return []

    def analyze_sentiment(self, news_data):
        try:
            sentiments = []
            for news in news_data:
                inputs = tokenizer(news['title'], return_tensors="pt", truncation=True, max_length=512)
                outputs = model(**inputs)
                probabilities = torch.nn.functional.softmax(outputs.logits, dim=-1)
                positive_probability = probabilities[0][1].item()
                sentiments.append(positive_probability)
            return sum(sentiments) / len(sentiments) if sentiments else None
        except Exception as e:
            logging.error(f"Error in analyze_sentiment: {str(e)}")
            return None

    def calculate_technical_indicators(self, data):
        try:
            prices = np.array([price for _, price in data])
            
            def sma(data, period):
                return np.convolve(data, np.ones(period), 'valid') / period
            
            def rsi(data, period):
                delta = np.diff(data)
                gain = (delta > 0) * delta
                loss = (delta < 0) * -delta
                avg_gain = sma(gain, period)
                avg_loss = sma(loss, period)
                rs = avg_gain / avg_loss
                return 100 - (100 / (1 + rs))
            
            sma_14 = sma(prices, 14)[-1]
            rsi_14 = rsi(prices, 14)[-1]
            
            return {
                'SMA': sma_14,
                'RSI': rsi_14
            }
        except Exception as e:
            logging.error(f"Error in calculate_technical_indicators: {str(e)}")
            return {'SMA': None, 'RSI': None}

    def predict_price(self, data):
        try:
            X = np.array([[i, price] for i, (_, price) in enumerate(data)])
            y = np.array([price for _, price in data])
            
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
            
            scaler = StandardScaler()
            X_train_scaled = scaler.fit_transform(X_train)
            X_test_scaled = scaler.transform(X_test)
            
            model = RandomForestRegressor(n_estimators=100, random_state=42)
            model.fit(X_train_scaled, y_train)
            
            next_day = np.array([[len(data), data[-1][1]]])
            next_day_scaled = scaler.transform(next_day)
            prediction = model.predict(next_day_scaled)
            
            return prediction[0]
        except Exception as e:
            logging.error(f"Error in predict_price: {str(e)}")
            return None

    def get_fundamental_data(self, stock_number):
        try:
            # Existing code to get data from Minkabu
            url = f"https://minkabu.jp/stock/{stock_number}"
            response = requests.get(url)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            def extract_value(label):
                element = soup.find('th', string=label)
                if element and element.find_next('td'):
                    return element.find_next('td').text.strip().replace(',', '')
                return None
            
            per = extract_value('PER')
            pbr = extract_value('PBR')
            dividend_yield = extract_value('配当利回り')
            
            # New code to get ROE from Buffett Code
            buffett_url = f"https://www.buffett-code.com/company/{stock_number}/"
            buffett_response = requests.get(buffett_url)
            buffett_soup = BeautifulSoup(buffett_response.content, 'html.parser')
            
            roe = None
            meta_description = buffett_soup.find('meta', attrs={'name': 'description'})
            if meta_description:
                content = meta_description['content']
                roe_match = re.search(r'ROE（([\d.]+)%）', content)
                if roe_match:
                    roe = float(roe_match.group(1))
            
            return {
                'PER': float(per) if per else None,
                'PBR': float(pbr) if pbr else None,
                'Dividend_Yield': float(dividend_yield.replace('%', '')) if dividend_yield else None,
                'ROE': roe
            }
        except Exception as e:
            logging.error(f"Error in get_fundamental_data: {str(e)}")
            return {'PER': None, 'PBR': None, 'Dividend_Yield': None, 'ROE': None}

    def analyze_market_sentiment(self):
        try:
            url = "https://www.nikkei.com/markets/kabu/"
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Try multiple selectors to find the Nikkei index value
            nikkei_element = soup.select_one('.economic_value_now, .index-value, .index_value')
            if nikkei_element:
                nikkei_value = float(nikkei_element.text.replace(',', '').replace('円', '').strip())
                nikkei_change_element = soup.select_one('.economic_value_diff, .index-change, .index_change')
                if nikkei_change_element:
                    nikkei_change_text = nikkei_change_element.text.replace(',', '').replace('円', '').strip()
                    nikkei_change = float(nikkei_change_text[1:] if nikkei_change_text.startswith('+') else nikkei_change_text)
                    nikkei_percent = (nikkei_change / (nikkei_value - nikkei_change)) * 100
                    
                    if nikkei_percent > 1:
                        return "Bullish"
                    elif nikkei_percent < -1:
                        return "Bearish"
                    elif abs(nikkei_percent) > 2:
                        return "Volatile"
                    else:
                        return "Neutral"
            
            # Fallback: analyze overall market trend
            market_trend = self.analyze_overall_market_trend()
            return f"Based on overall market trend: {market_trend}"
        
        except Exception as e:
            logging.error(f"Error in analyze_market_sentiment: {str(e)}")
            return "Unable to determine (Error occurred)"

    def analyze_overall_market_trend(self):
        try:
            # Use yfinance to get Nikkei 225 data
            nikkei_data = yf.download("^N225", period="5d")
            if not nikkei_data.empty:
                start_price = nikkei_data['Close'].iloc[0]
                end_price = nikkei_data['Close'].iloc[-1]
                percent_change = ((end_price - start_price) / start_price) * 100
                
                if percent_change > 2:
                    return "Bullish"
                elif percent_change < -2:
                    return "Bearish"
                elif abs(percent_change) > 3:
                    return "Volatile"
                else:
                    return "Neutral"
            else:
                return "Neutral (insufficient data)"
        except Exception as e:
            logging.error(f"Error in analyze_overall_market_trend: {str(e)}")
            return "Neutral (Error occurred)"

    def get_company_name(self):
        try:
            url = f"https://finance.yahoo.co.jp/quote/{self.stock_number}.T"
            response = requests.get(url)
            soup = BeautifulSoup(response.content, 'html.parser')
            title_tag = soup.find('title')
            if title_tag:
                title = title_tag.text.strip()
                company_name = title.split('【')[0].strip()
                return company_name
            else:
                return "Company name not found"
        except Exception as e:
            logging.error(f"Error in get_company_name: {str(e)}")
            return "Company name not found"

    def get_stock_data(self):
        try:
            ticker = f"{self.stock_number}.T"
            end_date = datetime.now()
            start_date = end_date - timedelta(days=30)
            
            df = yf.download(ticker, start=start_date, end=end_date)
            if df.empty:
                return None
            
            df = df.reset_index()
            df['Date'] = pd.to_datetime(df['Date'])
            stock_data = [(row['Date'], row['Close']) for _, row in df.iterrows()]
            
            stock_data.sort(key=lambda x: x[0], reverse=True)
            return stock_data[:30]
        except Exception as e:
            logging.error(f"Error in get_stock_data: {str(e)}")
            return None

    def scrape_psr_pbr(self):
        try:
            url = f"https://minkabu.jp/stock/{self.stock_number}"
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()
            soup = BeautifulSoup(response.content, 'html.parser')
            
            psr = pbr = None
            
            rows = soup.find_all('tr', class_='ly_vamd')
            
            for row in rows:
                th = row.find('th', class_='ly_vamd_inner ly_colsize_3_fix tal wsnw')
                if th:
                    if th.text.strip() == 'PSR':
                        td = row.find('td', class_='ly_vamd_inner ly_colsize_9_fix fwb tar wsnw')
                        if td:
                            psr = float(td.text.strip().replace('倍', ''))
                    elif th.text.strip() == 'PBR':
                        td = row.find('td', class_='ly_vamd_inner ly_colsize_9_fix fwb tar wsnw')
                        if td:
                            pbr = float(td.text.strip().replace('倍', ''))
            
            return psr, pbr
        except Exception as e:
            logging.error(f"Error in scrape_psr_pbr: {str(e)}")
            return None, None

    def stop(self):
        self.running = False


class MAGIStockAnalysis(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
        
        if getattr(sys, 'frozen', False):
            # we are running in a bundle
            bundle_dir = sys._MEIPASS
        else:
            # we are running in a normal Python environment
            bundle_dir = os.path.dirname(os.path.abspath(__file__))
        self.flicker_timers = {}
        self.update_thread = None
        self.previous_results = {
            'casper': '',
            'balthasar': '',
            'melchior': ''
        }

        self.showFullScreen()
        self.setWindowState(Qt.WindowState.WindowFullScreen)

    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape:
            self.showNormal()
        super().keyPressEvent(event)

    def has_content_changed(self, component_name, new_content):
        if self.previous_results[component_name] != new_content:
            self.previous_results[component_name] = new_content
            return True
        return False

    def initUI(self):
        self.setWindowTitle('MAGI Stock Analysis System')
        self.setGeometry(100, 100, 1200, 800)
        self.setStyleSheet("background-color: #000000; color: #00ff00;")

        main_layout = QVBoxLayout()
        main_layout.setSpacing(10)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Header
        header = QLabel('MAGI Stock Analysis System')
        header.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header.setStyleSheet("font-size: 24px; color: #ff8c00; margin-bottom: 10px;")
        main_layout.addWidget(header)

        # Input section
        input_layout = QHBoxLayout()
        self.stock_input = QLineEdit()
        self.stock_input.setPlaceholderText("Enter stock number")
        self.price_input = QLineEdit()
        self.price_input.setPlaceholderText("Purchase price (optional)")
        analyze_button = QPushButton("Analyze")
        analyze_button.clicked.connect(self.analyze_stock)

        # Style for input fields
        input_style = """
            QLineEdit {
                background-color: #001a1a;
                color: #00ff00;
                border: 1px solid #00ff00;
                border-radius: 5px;
                padding: 5px;
            }
        """
        self.stock_input.setStyleSheet(input_style)
        self.price_input.setStyleSheet(input_style)

        # Specific style for Analyze button with orange rectangle
        analyze_button.setStyleSheet("""
            QPushButton {
                background-color: #001a1a;
                color: #00ff00;
                border: 2px solid #ff8c00;
                border-radius: 5px;
                padding: 5px;
            }
            QPushButton:hover {
                background-color: #002a2a;
            }
        """)
        
        input_layout.addWidget(self.stock_input)
        input_layout.addWidget(self.price_input)
        input_layout.addWidget(analyze_button)
        main_layout.addLayout(input_layout)

        # MAGI components
        magi_layout = QHBoxLayout()
        magi_layout.setSpacing(10)
        self.melchior = self.create_magi_component("MELCHIOR • 1")
        self.balthasar = self.create_magi_component("BALTHASAR • 2")
        self.casper = self.create_magi_component("CASPER • 3")
        magi_layout.addWidget(self.melchior)
        magi_layout.addWidget(self.balthasar)
        magi_layout.addWidget(self.casper)
        main_layout.addLayout(magi_layout, stretch=1)

        self.setLayout(main_layout)

    def create_magi_component(self, title):
        component = QWidget()
        component.setStyleSheet("""
            background-color: #001a1a;
            border: 2px solid #ff8c00;
            border-radius: 5px;
        """)
        layout = QVBoxLayout(component)
        layout.setContentsMargins(5, 5, 5, 5)
        
        title_label = QLabel(title)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet("font-size: 18px; color: #ff8c00; background-color: transparent;")
        
        content = QTextEdit()
        content.setReadOnly(True)
        content.setStyleSheet("border: none; background-color: transparent; color: #00ff00;")
        
        layout.addWidget(title_label)
        layout.addWidget(content)
        
        return component

    def start_flicker(self, component):
        if component not in self.flicker_timers:
            timer = QTimer(self)
            timer.timeout.connect(lambda: self.flicker_effect(component))
            timer.start(100)  # Flicker every 100ms
            self.flicker_timers[component] = timer

    def stop_flicker(self, component):
        if component in self.flicker_timers:
            self.flicker_timers[component].stop()
            del self.flicker_timers[component]
            component.setStyleSheet("border: 2px solid #ff8c00; background-color: #001a1a;")

    def flicker_effect(self, component):
        current_style = component.styleSheet()
        if "background-color: #001a1a" in current_style:
            component.setStyleSheet("border: 2px solid #ff8c00; background-color: #005a5a;")  # Brighter color
        else:
            component.setStyleSheet("border: 2px solid #ff8c00; background-color: #001a1a;")

    def analyze_stock(self):
        stock_number = self.stock_input.text()
        purchase_price = self.price_input.text()
        if purchase_price.lower() == 'n/a' or purchase_price == '':
            purchase_price = None
        else:
            try:
                purchase_price = float(purchase_price)
            except ValueError:
                self.show_error("Invalid purchase price. Using N/A.")
                purchase_price = None

        # Start flickering
        for component in [self.casper, self.balthasar, self.melchior]:
            self.start_flicker(component)
            component.findChild(QTextEdit).setText("Loading...")

        # Stop existing update thread if running
        if self.update_thread and self.update_thread.isRunning():
            self.update_thread.stop()
            self.update_thread.wait()

        # Start new update thread
        self.update_thread = StockUpdateThread(stock_number)
        self.update_thread.update_signal.connect(lambda data: self.update_display(data, purchase_price))
        self.update_thread.start()

    def update_display(self, data, purchase_price):
        try:
            current_price = data['current_price']
            company_name = data['company_name']
            nikkei_sentiment = data['nikkei_sentiment']
            yahoo_sentiment = data['yahoo_sentiment']
            stock_data = data['stock_data']
            psr, pbr = data['psr'], data['pbr']
            technical_indicators = data['technical_indicators']
            price_prediction = data['price_prediction']
            fundamental_data = data['fundamental_data']
            market_sentiment = data['market_sentiment']

            overall_sentiment = (nikkei_sentiment + yahoo_sentiment) / 2 if nikkei_sentiment is not None and yahoo_sentiment is not None else None
            overall_sentiment_text = self.sentiment_to_text(overall_sentiment) if overall_sentiment is not None else "Insufficient data"

            matched_pattern = self.identify_pattern(stock_data) if stock_data else "Unable to retrieve stock data"
            psr_score, pbr_score, psr_comment, pbr_comment = self.evaluate_psr_pbr(psr, pbr)
            recommendation = self.get_action_recommendation(
                overall_sentiment_text, matched_pattern, stock_data, psr, pbr, purchase_price,
                technical_indicators, price_prediction, fundamental_data, market_sentiment
            )

            # Update CASPER
            casper_content = (
                f"Company: {company_name}\n\n"
                f"Nikkei Sentiment: {self.sentiment_to_text(nikkei_sentiment)}\n"
                f"Yahoo Sentiment: {self.sentiment_to_text(yahoo_sentiment)}\n"
                f"Overall Sentiment: {overall_sentiment_text}\n\n"
                f"Market Sentiment: {market_sentiment}"
            )
            if self.has_content_changed('casper', casper_content):
                self.update_component_with_flicker(self.casper, casper_content)
            else:
                self.casper.findChild(QTextEdit).setText(casper_content)

            # Update BALTHASAR
            sma = technical_indicators['SMA'] if technical_indicators and 'SMA' in technical_indicators else None
            rsi = technical_indicators['RSI'] if technical_indicators and 'RSI' in technical_indicators else None
            balthasar_content = (
                f"30-Day Pattern: {matched_pattern}\n"
                f"Recommended Action: {recommendation}\n\n"
                f"Technical Indicators:\n"
                f"SMA: {f'{sma:.2f}' if sma is not None else 'N/A'}\n"
                f"RSI: {f'{rsi:.2f}' if rsi is not None else 'N/A'}\n\n"
                f"Price Prediction: ¥{f'{price_prediction:.2f}' if price_prediction is not None else 'N/A'}"
            )
            if self.has_content_changed('balthasar', balthasar_content):
                self.update_component_with_flicker(self.balthasar, balthasar_content)
            else:
                self.balthasar.findChild(QTextEdit).setText(balthasar_content)

            # Update MELCHIOR
            current_price_text = f"¥{current_price:.2f}" if current_price is not None else "N/A"
            purchase_price_text = f"¥{purchase_price:.2f}" if purchase_price is not None else "N/A"
            psr_text = f"{psr:.2f}" if psr is not None else "N/A"
            pbr_text = f"{pbr:.2f}" if pbr is not None else "N/A"
            
            melchior_content = (
                f"Current Price: {current_price_text}\n"
                f"Purchase Price: {purchase_price_text}\n"
                f"Price Difference: {self.calculate_price_difference(current_price, purchase_price)}\n\n"
                f"PSR: {psr_text} - {psr_comment}\n"
                f"PBR: {pbr_text} - {pbr_comment}\n\n"
                f"Fundamental Data:\n"
                f"PER: {fundamental_data.get('PER', 'N/A')}\n"
                f"Dividend Yield: {fundamental_data.get('Dividend_Yield', 'N/A')}%\n"
                f"ROE: {fundamental_data.get('ROE', 'N/A')}%"
            )
            if self.has_content_changed('melchior', melchior_content):
                self.update_component_with_flicker(self.melchior, melchior_content)
            else:
                self.melchior.findChild(QTextEdit).setText(melchior_content)

        except Exception as e:
            logging.error(f"Error in update_display: {str(e)}")
            self.show_error(f"An error occurred while updating the display: {str(e)}")

    def update_component_with_flicker(self, component, new_text):
        self.start_flicker(component)
        component.findChild(QTextEdit).setText(new_text)
        QTimer.singleShot(500, lambda: self.stop_flicker(component))

    def show_error(self, message):
        for component in [self.casper, self.balthasar, self.melchior]:
            component.findChild(QTextEdit).setText(message)

    def sentiment_to_text(self, score):
        if score is None:
            return "No data"
        if score > 0.8:
            return "Very Negative"
        elif score > 0.6:
            return "Negative"
        elif score > 0.4:
            return "Neutral"
        elif score > 0.2:
            return "Positive"
        else:
            return "Very Positive"

    def identify_pattern(self, stock_data):
        if stock_data is None or len(stock_data) < 5:
            return "Insufficient data for pattern identification"
        
        prices = [price for _, price in stock_data]
        dates = [date for date, _ in stock_data]
        
        # Reverse the lists to have oldest data first
        prices = prices[::-1]
        dates = dates[::-1]
        
        n = len(prices)
        changes = np.diff(prices)
        
        def is_increasing(data):
            return np.all(np.diff(data) >= 0)
        
        def is_decreasing(data):
            return np.all(np.diff(data) <= 0)
        
        def find_peaks(data, order=3):
            peaks = []
            for i in range(order, len(data) - order):
                if all(data[i] > data[i-j] for j in range(1, order+1)) and all(data[i] > data[i+j] for j in range(1, order+1)):
                    peaks.append(i)
            return np.array(peaks)
        
        def find_troughs(data, order=3):
            troughs = []
            for i in range(order, len(data) - order):
                if all(data[i] < data[i-j] for j in range(1, order+1)) and all(data[i] < data[i+j] for j in range(1, order+1)):
                    troughs.append(i)
            return np.array(troughs)
        
        # Upward and Downward Trends
        if is_increasing(prices):
            return "Upward Trend"
        elif is_decreasing(prices):
            return "Downward Trend"
        
        # V-Shape Recovery and Inverted V-Shape
        if n >= 5:
            if prices[0] > prices[1] > prices[2] < prices[3] < prices[4]:
                return "V-Shape Recovery"
            elif prices[0] < prices[1] < prices[2] > prices[3] > prices[4]:
                return "Inverted V-Shape"
        
        # Double Bottom and Double Top
        peaks = find_peaks(prices)
        troughs = find_troughs(prices)
        
        if len(troughs) >= 2 and troughs[-1] - troughs[-2] >= 5:
            if abs(prices[troughs[-1]] - prices[troughs[-2]]) / prices[troughs[-2]] < 0.03:
                return "Double Bottom"
        
        if len(peaks) >= 2 and peaks[-1] - peaks[-2] >= 5:
            if abs(prices[peaks[-1]] - prices[peaks[-2]]) / prices[peaks[-2]] < 0.03:
                return "Double Top"
        
        # Head and Shoulders
        if len(peaks) >= 3:
            if prices[peaks[1]] > prices[peaks[0]] and prices[peaks[1]] > prices[peaks[2]]:
                if abs(prices[peaks[0]] - prices[peaks[2]]) / prices[peaks[0]] < 0.03:
                    return "Head and Shoulders"
        
        # Triangles and Wedges
        if n >= 15:
            first_half = prices[:n//2]
            second_half = prices[n//2:]
            
            if is_increasing(first_half) and is_decreasing(second_half):
                return "Ascending Triangle"
            elif is_decreasing(first_half) and is_increasing(second_half):
                return "Descending Triangle"
            elif (max(first_half) > max(second_half) and min(first_half) < min(second_half)):
                return "Symmetrical Triangle"
            elif (max(first_half) > max(second_half) and min(first_half) > min(second_half)):
                return "Falling Wedge"
            elif (max(first_half) < max(second_half) and min(first_half) < min(second_half)):
                return "Rising Wedge"
        
        # Pennant and Flag
        if n >= 20:
            if is_increasing(prices[:5]) and np.all(np.abs(np.diff(prices[5:])) < np.mean(np.abs(np.diff(prices[:5])))):
                return "Bullish Pennant"
            elif is_decreasing(prices[:5]) and np.all(np.abs(np.diff(prices[5:])) < np.mean(np.abs(np.diff(prices[:5])))):
                return "Bearish Pennant"
            elif is_increasing(prices[:10]) and is_decreasing(prices[10:]):
                return "Bullish Flag"
            elif is_decreasing(prices[:10]) and is_increasing(prices[10:]):
                return "Bearish Flag"
        
        # Rounding Bottom and Top
        if n >= 15:
            first_third = prices[:n//3]
            last_third = prices[-n//3:]
            if is_decreasing(first_third) and is_increasing(last_third):
                return "Rounding Bottom"
            elif is_increasing(first_third) and is_decreasing(last_third):
                return "Rounding Top"
        
        return "No specific pattern identified"

    def evaluate_psr_pbr(self, psr, pbr):
        psr_score = 0
        pbr_score = 0
        psr_comment = ""
        pbr_comment = ""
        
        if psr is not None:
            if psr > 4:
                psr_score = -1
                psr_comment = "Company may be overvalued based on PSR."
            elif 1 <= psr <= 2:
                psr_score = 1
                psr_comment = "Company may be undervalued based on PSR."
            else:
                psr_comment = "PSR is in a moderate range."
        else:
            psr_comment = "PSR data not available."
        
        if pbr is not None:
            if pbr > 3:
                pbr_score = -1
                pbr_comment = "Company may be overvalued based on PBR."
            elif pbr < 1:
                pbr_score = 1
                pbr_comment = "Company may be undervalued based on PBR."
            else:
                pbr_comment = "PBR is in a moderate range."
        else:
            pbr_comment = "PBR data not available."
        
        return psr_score, pbr_score, psr_comment, pbr_comment

    def get_action_recommendation(self, public_opinion, stock_trend, stock_price_data, psr, pbr, purchase_price,
                                technical_indicators, price_prediction, fundamental_data, market_sentiment):
        if not stock_price_data:
            return "Insufficient data for recommendation"
        
        opinion_score = {"Very Positive": 2, "Positive": 1, "Neutral": 0, "Negative": -1, "Very Negative": -2}
        trend_score = {"V-Shape Recovery": 1, "Upward Trend": 1, "Downward Trend": -1, "No specific pattern identified": 0}
        
        psr_score, pbr_score, _, _ = self.evaluate_psr_pbr(psr, pbr)
        
        total_score = (
            opinion_score.get(public_opinion, 0) + 
            trend_score.get(stock_trend, 0) + 
            psr_score + 
            pbr_score
        )
        
        prices = [price for _, price in stock_price_data]
        current_price = prices[0]
        avg_price = np.mean(prices)
        std_dev = np.std(prices)
        
        # User owns the stock if purchase_price is not None
        owns_stock = purchase_price is not None
        
        if owns_stock:
            price_change = (current_price - purchase_price) / purchase_price * 100
            
            if total_score > 1:
                if price_change > 0:
                    action = "Hold"
                    explanation = f"Positive outlook. You're currently up {price_change:.2f}%. Consider holding for potential further gains."
                else:
                    action = "Hold"
                    explanation = f"Positive outlook despite current loss. You're currently down {abs(price_change):.2f}%. Consider holding for potential recovery."
            elif total_score < -1:
                if price_change > 0:
                    action = "Consider Selling"
                    explanation = f"Negative outlook despite current gain. You're currently up {price_change:.2f}%. Consider selling to lock in profits."
                else:
                    action = "Consider Selling"
                    explanation = f"Negative outlook. You're currently down {abs(price_change):.2f}%. Consider selling to minimize losses."
            else:
                action = "Hold and Monitor"
                explanation = f"Mixed signals. You're currently {'up' if price_change > 0 else 'down'} {abs(price_change):.2f}%. Monitor the stock closely for changes in sentiment or market trends."
            
            # Add additional context based on significant gains or losses
            if price_change > 20:
                explanation += " However, with significant gains, consider taking partial profits."
            elif price_change < -20:
                explanation += " However, with significant losses, reassess your investment thesis."
        else:
            # Logic for users who don't own the stock
            if total_score > 1:
                target_price = max(current_price * 0.99, avg_price - 0.5 * std_dev)
                action = f"Consider Buying (Target: ¥{target_price:.2f})"
                explanation = "Overall positive outlook. Consider buying near the suggested target price."
            elif total_score < -1:
                action = "Hold Off"
                explanation = "Overall negative outlook. It might be better to wait for a more favorable entry point."
            else:
                action = "Monitor"
                explanation = "Mixed signals. Monitor the stock for a clearer trend before making a decision."

        # Include new factors in the decision-making process
        if technical_indicators['RSI'] > 70:
            explanation += " RSI indicates the stock may be overbought."
        elif technical_indicators['RSI'] < 30:
            explanation += " RSI indicates the stock may be oversold."

        if market_sentiment == "Bullish":
            explanation += " Overall market sentiment is bullish."
        elif market_sentiment == "Bearish":
            explanation += " Overall market sentiment is bearish."

        return f"{action}\nExplanation: {explanation}"

    def calculate_price_difference(self, current_price, purchase_price):
        if purchase_price is None:
            return "N/A"
        price_difference = current_price - purchase_price
        price_percentage = (price_difference / purchase_price) * 100
        return f"¥{price_difference:.2f} ({price_percentage:.2f}%)"

    def closeEvent(self, event):
        if self.update_thread and self.update_thread.isRunning():
            self.update_thread.stop()
            self.update_thread.wait()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = MAGIStockAnalysis()
    ex.show()
    sys.exit(app.exec())
